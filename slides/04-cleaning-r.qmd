# Cleaning in R {.background-secondary}

:::{.notes}

Before we jump in I just want to preface this section with the understanding that this material isn't about learning all of the various ways you may be able to solve every unique data cleaning problem. There's no way to cover that much material, and on top of that, for every data cleaning issue you encounter in your data, there are probably 10 different ways to solve that issue. So I am sharing this to say, that this section is not about learning a specific set of data cleaning functions, it is about learning a standardized way of thinking through a data cleaning process and pulling from the available R functions, some of which we will learn today, to work through that process. 

:::

## Packages

- R has many built in (base) functions
- We can also use functions that live in packages that we can install onto our computer

- Once installed, there are two ways to call packages
  - You may see both methods used in these slides

<br>

::: columns
::: {.column width="50%"}

Using `library()`

```{r echo=TRUE, eval=FALSE}
library(dplyr)

select(df, var1, var2) 

```
:::

::: {.column width="50%"}

Using Namespacing `package::function()`

```{r echo=TRUE, eval=FALSE}

# library(dplyr) not needed

dplyr::select(df, var1, var2) 

```
:::
:::

:::{.notes}

Foundational

:::

## Tidyverse

<br>

An opinionated collection of R packages designed for data science

All packages share an underlying design philosophy, grammar, and data structures

<br>

::: {layout-nrow=4}

![](images/dplyr.png)
![](images/tidyr.png)
![](images/stringr.png)
![](images/readr.png)
![](images/purrr.png)

:::

## Tidyverse

<br>

Selecting `test_score` and `grade_level` from our data frame named `sch_data`

<br>

::: columns
::: {.column width="50%"}

[Tidy Evaluation](https://dplyr.tidyverse.org/articles/programming.html)

<br>

```{r echo=FALSE}

sch_data <- tibble::tribble(~id, ~test_score, ~grade_level,
                350, 3,
                380, 4,
                290, 3)

```

```{r echo=TRUE}

select(sch_data, test_score, 
       grade_level)

```
:::

::: {.column width="50%"}

Base R

<br>

```{r echo=TRUE}

sch_data[ , c("test_score", 
              "grade_level")]

```
:::
:::

## Pipes

-   2014+ magrittr pipe `%>%`

-   2021+ (R $\geq$ 4.1.0) native R pipe `|>`

. . .

Isabella VelÃ¡squez's blog post [*Understanding the native R pipe* \|\>](https://ivelasq.rbind.io/blog/understanding-the-r-pipe/) (2022)

<br>

. . .

::: columns
::: {.column width="50%"}
```{r echo=TRUE, eval=FALSE}

sch_data <- select(sch_data, id, 
                    test_score)

sch_data <- filter(sch_data, 
                    test_score > 300)

```
:::

::: {.column width="50%"}
```{r}
#| echo: true
#| eval: false

sch_data <- sch_data |>
  select(id, test_score) |>
  filter(test_score > 300)

```
:::
:::

. . .

<br>

To turn on the native pipe:

`Tools` â†’ `Global Options` â†’ `Code` â†’ `Editing` â†’ `Use Native Pipe Operator`

## Operators

::: columns
::: {.column width="50%"}

Comparison operators

- `==` equal to
- `!=` not equal to
- `<` less than
- `>` greater than
- `%in%` value is present within

```{r eval=FALSE}

df |>
  filter(city %in% c("boston","philly"))

```

:::

::: {.column width="50%"}

Assignment operators

- `<-` Assign value to an object
- `=` Assign value to an object

```{r eval = FALSE}

df <- df |>
  mutate(year = "2024")

```

:::
:::

## Scenario

#### Take 5 minutes to open and look at our data file.

1. Log in to Posit Cloud and navigate to our project
    - [**https://posit.cloud/content/7872027**](https://posit.cloud/content/7872027)
2. Open the `data` folder and open "sample_tch_svy_raw.xlsx"
    - Notice that the "labels" tab has some basic information about the variables

![](images/sample-data.PNG){fig-align="center"}

```{r}
#| echo: false
#| cache: false
countdown(minutes = 5, font_size = "2em")

```


## Import our data

<br>

Common data importing functions

- `read_csv()`, `read_delim()` from the `readr` package

- `read_excel()` from the `readxl` package

- `read_sav()`, `read_sas()`, `read_dta()` from the `haven` package

- Learn more about importing multiple files at once [here](https://github.com/Cghlewis/data-wrangling-functions/wiki/Import-Files)

<br>

. . .

**Which function should we use to read in our sample data?**ðŸ¤”

## Import our file

::: columns
 
::: {.column width="50%"}

- `read_excel()` has several arguments. 
  - path
  - sheet = NULL
  - col_names = TRUE
  - na = ""
  - skip = 0
- Type `?read_excel()` in your console to see more arguments

:::

::: {.column width="50%"}

![](images/read_excel.PNG){fig-align="center"}

:::
:::


## [Exercise]{style="color:#ccd64d"}{.background-secondary}

<br>

### Take 3 minutes to import the data.

<br>

1. Open "exercises.Rmd" in our Posit Cloud project.
2. Navigate to exercise 1.
3. Update the code and run the code chunks using the green arrows.
4. If you get stuck, you can open "solutions.Rmd"

```{r}
#| echo: false
#| cache: false
countdown(minutes = 3, font_size = "2em")

```

## Review our data

::: columns
::: {.column width="50%"}

- How many rows?
  - In this hypothetical situation, we assume we are not missing any cases
  - However, there may be duplicates
- How many columns?
  - Compare to our data dictionary
- What are the variable values and ranges?
  - Compare to our data dictionary
- How much missing data do we have?

:::

::: {.column width="50%"}

There are several functions we can use to explore data

- `dplyr::glimpse()`
- `skimr::skim()`
- `base::summary()`
- **`summarytools::dfSummary()`**
- `Hmisc::describe()`

:::
:::

## [Exercise]{style="color:#ccd64d"}{.background-secondary}

<br>

### Take 5 minutes to review our data.

1. Navigate to exercise 2.
2. Run the code. 
    - Write down any potential issues you see in the data.
3. Open "sample_tch_svy_data_dictionary.xlsx" in the `docs` folder. 
    - What issues do you see when you compare the data to our data dictionary?
4. Review "sample_tch_svy_cleaning-plan.txt" in the `docs` folder. 
    - How does it compare to the issues you wrote down?

```{r}
#| echo: false
#| cache: false
countdown(minutes = 5, font_size = "2em")

```

:::{.notes}

So we are going to follow this data cleaning plan for the rest of this section

:::


## Adjust the sample

<br>

There are two key functions we can use to both identify and remove duplicates in our data

<br>

  - `janitor::get_dupes()`
    - Tells you which rows contain duplicate unique identifiers, if any
  - `dplyr::distinct()`
    - Keeps the first instance of a duplicate unique identifier
      - Helpful to first use `dplyr::arrange()` so that your data is always sorted the same way before dropping your duplicates
      
:::{.notes}

So the next step in our checklist is to adjust the sample
And we found some duplicates in our sample

:::
  
## Adjust the sample

<br>

::: columns
::: {.column width="50%"}

Check for duplicates

```{r}
#| echo: true
#| eval: false

df |>
  get_dupes(id_vars)

```

- Replace `id_vars` with your unique identifier
- If you have more than one variable that uniquely identifies rows, use `c(first_name, last_name)`

:::

::: {.column width="50%"}

Remove duplicates

```{r}
#| echo: true
#| eval: false
 
df |>
  arrange(another_identier) |>
  distinct(id_vars, 
           .keep_all = TRUE)

```
- Replace `another_identifier` with a variable that makes your duplicates unique (e.g., "date")
  - The default is to sort values in ascending order
- Replace `id_vars` with your unique identifier/s
- Always add the argument *.keep_all = TRUE*


:::
:::


## [Exercise]{style="color:#ccd64d"}{.background-secondary}

<br>

### Take 5 minutes to check for and remove duplicates.

1. Navigate to exercise 3.
2. Run the code to check for duplicates. 
    - Which `tch_id` is duplicated?
3. Run the code to remove our duplicates. 
    - Our documented rule is that if both surveys are complete, keep the most recently completed row.
4. Run a check to make sure duplicates are removed.
5. Run the code to confirm that we kept the most recent submission of the duplicate survey ("2024-04-02").

```{r}
#| echo: false
#| cache: false
countdown(minutes = 5, font_size = "2em")

```

## De-identify data

<br>

The functions used here will depend on what is required.

<br>

Examples of functions you might use:

- `dplyr::select()` to drop variables
- `dplyr::case_when()` or `dplyr::recode()` to collapse categories/recode values
- `dplyr::*_join()` to merge in study unique IDs
- `stringr::str_remove_all()` or `stringr::str_replace_all()` to redact character values


For our sample data we are going to use the following.

1. `dplyr::select()` to drop identifying variables and
2. `dplyr::case_when()` to recategorize names into our unique study ID values

## De-identify data - Select

<br>


::: columns
::: {.column width="50%"}

To select variables of interest

```{r}
#| echo: true
#| eval: false

df |>
  select(varname1, varname2, varname3)

```


:::

::: {.column width="50%"}

To drop variables I add `-`

```{r}
#| echo: true
#| eval: false
 
df |>
  select(-varname1)

```

- If I had more than one variable to drop, I can use `-c(var1, var2)`

:::
:::

## De-identify data - Categorize

<br>

```{r}
#| echo: true
#| eval: false

df |>
  dplyr::mutate(new_var_name =
                  case_when(
                    var_name == old_value1 ~ new_value1,
                    var_name == old_value2 ~ new_value2,
                  ))

```


- To learn more about setting *default* values for `case_when()`, type `?case_when` in your console
- Note that there is a new function, `case_match()`, that is worth looking in to. It reduces repetition in the syntax.

## [Exercise]{style="color:#ccd64d"}{.background-secondary}

<br>

### Take 5 minutes to de-identify our data

1. Navigate to exercise 4.
2. Run the code to create a `sch_id` variable.
    - Review the new variable after it is created.
3. Run the code to drop our identifying variables.
    - Review to make sure those variables were removed.

```{r}
#| echo: false
#| cache: false
countdown(minutes = 5, font_size = "2em")

```

## Rename variables

Two functions we can use to rename variables

- `dplyr::rename()`
    - Commonly used to rename just a few variables
- `purrr::set_names()`
    - Used to rename all of our variables
    - Variables must be in the exact right order

<br>

::: columns
::: {.column width="50%"}

Rename one variable

```{r}
#| echo: true
#| eval: false

df |>
  rename(new_name = old_name)

```

:::

::: {.column width="50%"}

Rename all variables

```{r}
#| echo: true
#| eval: false
 
df |>
  set_names(c("name1", "name2", "name3"))

```

:::
:::

## [Exercise]{style="color:#ccd64d"}{.background-secondary}

<br>

### Take 3 minutes to rename variables

1. Navigate to exercise 3.
2. Review the current variable names.
3. Rename variables according to our data dictionary.
4. Check variable names again to make sure the renaming worked.

```{r}
#| echo: false
#| cache: false
countdown(minutes = 3, font_size = "2em")

```


## Normalize variables

There are several functions that can help us remove unexpected values from our variables. 

Some examples of those include:

- `stringr::str_remove_all()`
- `stringr::str_replace_all()`
- `readr::parse_number()`

<br>

Say this is our data

```{r echo=FALSE}

library(stringr)
library(readr)

df <- tibble::tribble(~id, ~income,
                      1, "$32,000",
                      2, "120000",
                      3, "$45,000")

df

```


## Normalize variables

<br>

::: columns
::: {.column width="50%"}

Remove character values with `stringr::str_remove_all()`

```{r}
#| echo: true

df |>
  dplyr::mutate(income = 
                  str_remove_all(income, "\\$|,"))

```

- Notice that our variable is still character type

:::

::: {.column width="50%"}

Remove character values with `readr::parse_number()`

```{r}
#| echo: true
 
df |>
  dplyr::mutate(income = 
                  parse_number(income))

```

- Notice that `parse_number()` converts our variable to numeric type

:::
:::

## [Exercise]{style="color:#ccd64d"}{.background-secondary}

<br>

### Take 3 minutes to normalize our `tch_yrs` variable

1. Navigate to exercise 6.
2. Review the current values for `tch_yrs`.
3. Remove all non-numeric values from this variable.
4. Review the new values in `tch_yrs`.

```{r}
#| echo: false
#| cache: false
countdown(minutes = 3, font_size = "2em")

```

## Update variable type

Depending on what is needed, there are several functions we can use to change variable types.

Some examples include:

- `as.numeric()`
- `as.character()`
- `as.Date()`
- Several functions in the `lubridate` package to assist with converting dates
- `janitor::excel_numeric_to_date()` can be very helpful at times

## Update variable type

It's important to normalize variables **before** converting types (especially when converting from character to numeric)

<br>

::: columns
::: {.column width="50%"}

Our data without normalizing

```{r}
#| echo: true

df

```

:::

::: {.column width="50%"}

When we try to convert `income` to numeric....

```{r}
#| echo: true
#| warning: true
 
df |>
  dplyr::mutate(income = 
                  as.numeric(income))

```

We end up converting several values to `NA` (notice our warning)

:::
:::

## [Exercise]{style="color:#ccd64d"}{.background-secondary}

<br>

### Take 3 minutes to convert `tch_yrs` to numeric

1. Navigate to exercise 7.
2. Review the current variable type for `tch_yrs`.
3. Convert the variable to numeric.
4. Review the new variable type for `tch_yrs`.

```{r}
#| echo: false
#| cache: false
countdown(minutes = 3, font_size = "2em")

```

## Recode variables

Common functions for recoding values are

- `dplyr::case_when()`
- `dplyr::recode()`
- `tidyr::replace_na()`

<br>

::: columns
::: {.column width="50%"}

```{r eval=FALSE}

df |>
  mutate(newvar = 
           recode(oldvar,
                  `oldvalue` = newvalue))

```

:::

::: {.column width="50%"}

```{r eval=FALSE}

df |> 
  mutate(newvar = 
           replace_na(oldvar, 
                      replace = 0))

```

:::
:::

## Recode variables

<br>

`dplyr::across()` allows you to apply the same transformation across multiple columns

<br>

```{r eval=FALSE}

df |>
  mutate(across(var1:var3, 
                ~ case_when(
                  . == oldvalue1 ~ newvalue1,
                  . == oldvalue2 ~ newvalue2
                )))

```


If you don't want to save over the existing variables, you can add the argument *.names* which lives in the `dplyr::across()` function. This creates new variables with new names.

## [Exercise]{style="color:#ccd64d"}{.background-secondary}

<br>

### Take 5 minutes to recode variables

1. Navigate to exercise 8.
2. Recode the blank values for the `grade` variables.  
    - Check to see if the recoding worked.
3. Recode the `mathanx` variable.  
    - Check to see that the recoding worked.

```{r}
#| echo: false
#| cache: false
countdown(minutes = 5, font_size = "2em")

```

## Construct new variables

- The most important function for constructing new variables is `dplyr::mutate()`

- From there, other functions may be required. For today, we are going to use `rowSums()` which allows us to create sum scores for each row

<br>

::: columns
::: {.column width="50%"}

The default is to **not** calculate a sum if there are any `NA` values

```{r eval=FALSE}

df |>
  mutate(newvar = rowSums(
    across(var1:var3)))

```

:::

::: {.column width="50%"}

If you want to calculate a sum even if there are NA values, add *na.rm = TRUE*

```{r eval=FALSE}

df |>
  mutate(newvar = rowSums(
    across(var1:var3), na.rm = TRUE))

```

:::
:::

## [Exercise]{style="color:#ccd64d"}{.background-secondary}

<br>

### Take 3 minutes to construct `gad_sum`

1. Navigate to exercise 9.
2. Calculate `gad_sum`
3. Review summary information for the new variable.

```{r}
#| echo: false
#| cache: false
countdown(minutes = 3, font_size = "2em")

```
